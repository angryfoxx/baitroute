Metadata-Version: 2.1
Name: baitroute
Version: 0.1.0
Summary: A configurable HTTP honeypot library for Python web applications
Home-page: https://github.com/utkusen/baitroute
Author: Utku Sen
Author-email: utkusen@gmail.com
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Requires-Python: >=3.6
Description-Content-Type: text/markdown
Requires-Dist: pyyaml>=5.1

# BaitRoute

A honeypot library that helps you detect and track attackers by serving bait endpoints.

## What Problem Does It Solve?

In today's cybersecurity landscape, web applications are constantly targeted by automated scanners, vulnerability assessment tools, and potential attackers. These tools often probe for common vulnerabilities, sensitive endpoints, and misconfigurations. BaitRoute helps you:

1. **Detect Malicious Activity**: By creating realistic-looking honeypot endpoints that mimic common vulnerabilities and sensitive resources
2. **Waste Attacker's Time**: Make automated tools and attackers spend time investigating fake endpoints
3. **Gather Intelligence**: Collect information about attack patterns, tools, and techniques used against your application
4. **Early Warning System**: Get alerted about potential reconnaissance or attack attempts before they reach your actual endpoints

## Benefits

- **Easy Integration**: Seamlessly integrates with popular web frameworks in Go, Python, and Java
- **Minimal Overhead**: Runs alongside your existing application without impacting performance
- **Configurable**: Use YAML files to define bait endpoints, making it easy to maintain and update
- **Framework Agnostic**: Support for multiple frameworks in each language
- **Alert Integration**: Can send alerts to various security tools and SIEM systems
- **Selective Loading**: Load only the bait rules you need
- **Custom Responses**: Configure status codes, headers, and response bodies to create realistic-looking endpoints

## Features

- Serve realistic-looking bait endpoints (e.g., `.aws/credentials`, `.env`, `wp-config.php`)
- Track attacker information (IP, headers, request body)
- Customizable responses and status codes
- Easy integration with existing web applications
- Support for multiple programming languages (Go, Python, Java, JavaScript)

## Supported Languages and Frameworks

The library currently supports the following languages and frameworks:

### Go
- Standard `net/http` package
- Fiber
- Gin
- Chi
- Echo
- FastHTTP

### Python
- Flask
- FastAPI
- Django

### JavaScript
- Express
- Native HTTP
- Node.js

### Java
- Spring Boot

## Installation

### Prerequisites

Before starting, make sure you have:
1. Git installed
2. The rules directory containing YAML files (bait endpoint definitions)

### Getting the Rules

The rules are included in the main repository. When you clone the project, you'll get them automatically:
```bash
git clone https://github.com/utkusen/baitroute.git
cp -r baitroute/rules ./rules
```

The directory structure should look like:
```
your-project/
├── rules/        # Copied from the cloned repository
├── main.go       # Your application code
└── ...
```

## Usage

### Go Implementation

1. **Installation**

In your existing Go project, add the baitroute library to your dependencies:
```bash
go get github.com/utkusen/baitroute/go
```

2. **Basic Usage**

Create a file named `main.go`:
```go
package main

import (
    "github.com/utkusen/baitroute/go/pkg/baitroute"
    "log"
    "net/http"
)

func main() {
    // Create a new baitroute instance
    d := baitroute.New("./rules")

    // Set up alert handler
    d.SetAlertHandler(func(alert baitroute.Alert) {
        log.Printf("Bait endpoint hit: %s %s", alert.Method, alert.Path)
        log.Printf("Source IP: %s", alert.RemoteAddr)
        if clientIP := alert.Headers.Get("True-Client-IP"); clientIP != "" {
            log.Printf("True-Client-IP: %s", clientIP)
        }
        if forwardedFor := alert.Headers.Get("X-Forwarded-For"); forwardedFor != "" {
            log.Printf("X-Forwarded-For: %s", forwardedFor)
        }
    })

    // Register bait endpoints
    http.HandleFunc("/", d.Handler)

    log.Printf("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

3. **Running**
```bash
# Make sure rules directory is in the same directory as main.go
go run main.go
```

### Python Implementation

1. **Installation**

Install the library directly from GitHub:
```bash
pip install git+https://github.com/utkusen/baitroute.git#subdirectory=py
```

2. **Basic Usage with Flask**

```python
from flask import Flask
from baitroute.flask import BaitRoute

app = Flask(__name__)

# Create baitroute instance
baitroute = BaitRoute("./rules")

# Set up alert handler
@baitroute.alert_handler
def handle_alert(alert):
    print(f"Bait endpoint hit: {alert.method} {alert.path}")
    print(f"Source IP: {alert.remote_addr}")
    if "True-Client-IP" in alert.headers:
        print(f"True-Client-IP: {alert.headers['True-Client-IP']}")
    if "X-Forwarded-For" in alert.headers:
        print(f"X-Forwarded-For: {alert.headers['X-Forwarded-For']}")

# Register bait endpoints
app.register_blueprint(baitroute.blueprint)

if __name__ == "__main__":
    app.run()
```

Make sure to copy the rules directory to your project root:
```bash
git clone https://github.com/utkusen/baitroute.git
cp -r baitroute/rules ./rules
```

3. **Running**
```bash
# Make sure rules directory is in the same directory as app.py
python app.py
```

### Java (Spring Boot) Implementation

1. **Installation**

Add the following dependency to your `pom.xml`:
```xml
<dependency>
    <groupId>dev.baitroute</groupId>
    <artifactId>baitroute-java</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

2. **Basic Usage**

```java
import dev.baitroute.spring.SpringBaitRoute;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

@SpringBootApplication
public class Application {
    @Bean
    public SpringBaitRoute baitroute(RequestMappingHandlerMapping handlerMapping) {
        // Initialize baitroute with rules path
        SpringBaitRoute baitroute = new SpringBaitRoute("./rules", handlerMapping);
        
        // Set up alert handler
        baitroute.setAlertHandler(alert -> {
            System.out.println("Bait endpoint hit: " + alert.getPath());
            System.out.println("Method: " + alert.getMethod());
            System.out.println("Remote Address: " + alert.getRemoteAddress());
            
            String trueClientIp = alert.getHeaders().get("True-Client-IP");
            String xForwardedFor = alert.getHeaders().get("X-Forwarded-For");
            
            if (trueClientIp != null) {
                System.out.println("True-Client-IP: " + trueClientIp);
            }
            if (xForwardedFor != null) {
                System.out.println("X-Forwarded-For: " + xForwardedFor);
            }
        });
        
        return baitroute;
    }
}
```

Make sure to copy the rules directory to your project root:
```bash
git clone https://github.com/utkusen/baitroute.git
cp -r baitroute/rules ./rules
```

Note: For proper path matching in Spring Boot, add these properties to your `application.properties`:
```properties
spring.mvc.pathmatch.matching-strategy=ant_path_matcher
server.servlet.register-default-servlet=true
```

3. **Running**
```bash
# Make sure rules directory is in the project root
mvn spring-boot:run
```

### JavaScript Implementation

1. **Installation**

Install the library directly from GitHub:
```bash
npm install github:utkusen/baitroute#main/js
# or
yarn add github:utkusen/baitroute#main/js
```

2. **Basic Usage with Express**

```typescript
import express from 'express';
import { BaitRoute } from '@utkusen/baitroute';

const app = express();
const baitroute = new BaitRoute('./rules');

// Set up alert handler
baitroute.setAlertHandler((alert) => {
    console.log(`Bait endpoint hit: ${alert.method} ${alert.path}`);
    console.log(`Source IP: ${alert.remoteAddr}`);
    if (alert.headers['true-client-ip']) {
        console.log(`True-Client-IP: ${alert.headers['true-client-ip']}`);
    }
    if (alert.headers['x-forwarded-for']) {
        console.log(`X-Forwarded-For: ${alert.headers['x-forwarded-for']}`);
    }
});

// Register bait endpoints
app.use(baitroute.middleware());

app.listen(8080, () => {
    console.log('Server starting on :8080');
});
```

3. **Basic Usage with Node.js HTTP**

```typescript
import { createServer } from 'http';
import { BaitRoute } from '@utkusen/baitroute';

const baitroute = new BaitRoute('./rules');

// Set up alert handler
baitroute.setAlertHandler((alert) => {
    console.log(`Bait endpoint hit: ${alert.method} ${alert.path}`);
    console.log(`Source IP: ${alert.remoteAddr}`);
    if (alert.headers['true-client-ip']) {
        console.log(`True-Client-IP: ${alert.headers['true-client-ip']}`);
    }
    if (alert.headers['x-forwarded-for']) {
        console.log(`X-Forwarded-For: ${alert.headers['x-forwarded-for']}`);
    }
});

const server = createServer(baitroute.handler());

server.listen(8080, () => {
    console.log('Server starting on :8080');
});
```

Make sure to copy the rules directory to your project root:
```bash
git clone https://github.com/utkusen/baitroute.git
cp -r baitroute/rules ./rules
```

## Testing

After starting any of the implementations, you can test the bait endpoints:

```bash
# Test AWS credentials bait
curl http://localhost:8080/.aws/credentials

# Test environment file bait
curl http://localhost:8080/.env

# Test WordPress config bait
curl http://localhost:8080/wp-config.php
```

## Rule Format

Rules are defined in YAML files. Each rule specifies:
- Path
- HTTP method
- Response status code
- Content type
- Response body
- Custom headers (optional)

Example rule:
```yaml
- path: /.aws/credentials
  method: GET
  status: 200
  content-type: text/plain
  body: |
    [default]
    aws_access_key_id = AKIA...
    aws_secret_access_key = ...
```

## Security Considerations

1. **Production Use**
   - Always run bait endpoints on a separate port or domain from your main application
   - Monitor and analyze the alerts regularly
   - Consider rate limiting to prevent DoS attacks

2. **Alert Handling**
   - Store alerts securely
   - Don't expose sensitive information in responses
   - Consider integrating with your security monitoring systems (SIEM, etc.)

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details. 
